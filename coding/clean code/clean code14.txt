14．継続的改良
・clean code に向けて
  - 科学よりかは工芸品
    - 汚いコードではじめ，綺麗にしていくべき

  - 第一目的は，NOT「プログラムを動かす」こと
    - 動く「状態」を気にしよう




・下書きの特徴
  - 純粋なインスタンス変数の数が多い
  - 奇妙な文字列
  - ブロックの山
    - try_catch
    - Set
    - 構造が荒削り




・リファクタリング
  - 修正時期
    - 機能追加をすることで，保守可能性が失われそうなとき

  - クラスの導入
    - 多くの異なる引数に対して，同じ様なメゾッド
    - 基底クラスに全てのマーシャリングの振る舞いを作成
    - 継承クラスに落とし込む
    - 

  - ダメな修正
    - 構造に大量の変更を加える
    - いくつかのプログラムは二度と回復しない
    - 動作させるのが非常に困難

  - 正しい修正
    - TDD
      - システムを動かし続ける
      - システムを壊す変更は許されない
      - 変更時には，依然と同じ動作をすることが義務

    - テストスイート
      - 自動化された一揃いのテスト
      - 単体テストを常に作成
      - 規定の動作をしてると確信できる
      - インクリメンタル主義

  - 大量の細かな変更
    - 関数山の最後にスケルトンを追加
      - 最小限の破壊で，最大限の変更
      - 変更に進む前に，動作チェック
      - 起きな目標には，多くの小さなステップが必要
      - エラー処理の分離

  - 優れたソフトフェア設計は「分割」
    - 適切な場所を用意
    - 種類の異なるコードを異なる場所に分ける
    - 関心事の分離




・結論
  - ダメなコードは腐敗，発酵し，重荷となる
  - 急がば回れ
  - 時間が経過した依存性を断ち切るのは困難
  - コードを常に，できる限り綺麗に保つ
  - 腐り始めることを許してはならない




・
  - 
    - 
  - 
    - 
