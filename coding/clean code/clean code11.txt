11．システム
・街づくり
  - すべてを詳細には管理できん
    - 全体像の責任
    - 詳細に関心

  - 適切な抽象化とモジュール
    - 各コンポーネントの作業が効率化
    - 全体像を理解しなくても上手く行く

  - システム
    - 街づくりと同じ
    - 高レベルの抽象化



・システムの使用と構築を分離
  - システムを使う事と，構築することは全く異なる

  - 開始処理をランタイムロジックから分離
    - 開始処理はその場しのぎ
      - 遅延初期化/評価イディオムでは利点
      - ランタイムロジックと混在しがち
      - メゾットが2以上している（＝ROP違反）
      - 他との依存関数が問題になる
      - グローバルなコンテキストを知ることになる
      - 
        - 開始処理が大量に散在
	  - 重複
	  - 便利で小さなイディオムが全体を破壊

  - グローバルなコンテキストとは分離
    - グローバルな設定手順は，堅牢なシステム構築に反する




・mainの分離
  - 構築と使用の分離
    - 構築に関わる全ての局面をmainへ移動
    - システム内の残り
      - 各オブジェクトが適切に生成され，
      - 関連付けられているという前提のもとに設計

  - アプリケーション側は，mainや構築側の処理について無知でよい
    - あらゆるものが適切に構築されていると期待できる




・ファクトリ（pp 417）
  - アプリケーションがオブジェクトの生成に責任を持つ場合
    - e.g., 発注に追加するための品目のインスタンスを生成
  
  - 抽象ファクトリパターン
    - インスタンスを生成するタイミングをアプリケーションが制御
    - main → application
      - 生成の詳細をアプリケーションから分離
      - mainと同じ側にあるインスタンス生成の実装によって達成




・依存性注入（Dependency Injection: DI）
  - オブジェクトの利用と生成を分離
    - 依存性管理に対する制御反転（IoC）の適用
    - 第二の責務を別オブジェクトに移す
    - オブジェクトは自身の生成に関する責務に依存してはいけない
    - この大域的な責務は信頼できる機構「main or コンテナ」に委ねる

  - クラスは依存性解決のための直接的な手法は使わない．
    - 受動的．
    - セッタメゾット，コンストラクタ引数
    - 真の依存性注入
    - 依存オブジェクトは，設定ファイルか別モジュールで指定

  - 遅延初期化の長所
    - DIにおいても有用
    - 遅延評価の用途に用いて，同様の最適化効果を得る




・スケールアップ
  - 「最初から正しい」システムは，神話に過ぎない
    - 今日できるストーリを実装
    - 明日に向けてリファクタリングと拡張
    - イテレーティブでインクリメンタルな手法
    - TDD，clean code，refactoring

  - 適切に関心事を分離して保守

  - 重量小手なとの結びつきが強いと，分離した状態での単体テストは困難
    - あるビーンは別のビーンを継承できない
    - OOPさえむしばむ




・横断的関心事
  - 永続性の様な関心事
    - オブジェクトの自然なドメイン境界に横断的に表れる
    - 命名規約（フラットファイル，カラム名）
    - トランザクショナルな意味論の整合性維持

  - 横断的関心事
    - 永続化の手法を同じコードの繰り返しで多くのオブジェクトにまたがって実施
    - 問題なのは，細粒度にドメイン上の横断が起きる点

  - アスペクト指向プログラミング（AOP）
    - 横断的関心事に対して，モジュール構造を取り戻すアプローチ
    - アスペクト（モジュール）で指定
      - 簡易的な宣言．手続き型な構造．
      - 特定の関心事を実現
      - システム内の振る舞いのどの点に対し，整合性を維持したままで変更を加えるのか
      - 非侵入的（＝対象に対する手作業の変更が必要ない）




・Javaプロキシ
  - 個々のオブジェクトやクラスのメゾットをラップしたい時に有効
  - コードの量と複雑さが欠点
  - AOPでは，システム全体に渡るような実行を指定可能
    - プロキシではできない




・AOP
  - プロキシを内部で使用し，Pure Javaの世界でアスペクトを実装
    - ビジネスロジックをPOJO（Plain Old Java Object）で書ける
      - 純粋にドメインに集中できる
      - フレームワークの依存が無い
      - 単純でありテストが簡単

  - ロシア人形的デコレ―タ
    - 振る舞いの拡張
    - デコレ―タの追加も容易
    - アプリケーションとフレームワークを完全に切り離す
    - 詳細が閉じ込められているため綺麗

  - システムアーキテクチャのテスト実行
    - ドメインロジックをPOJOで記述
      - 柔軟に洗練されたモノへ進化させやすい
      - 事前の大規模設計（Big Design Up Front）が不要
      - BDUFはためらいのため変化に対応できない
        - 後続の設計の考えに影響
	- 舵のない状態に陥るわけではない
	- 状況の進化に伴ってコース変更が可能であり続けなければならない

  - 依存性が少ない設計
    - 抽象化とスコープの各レベルが単純
      - 高い可用性とパフォーマンス
      - 洗練されたものを柔軟に効率的に使用

  - 良いAPIとは
    - ほとんどの場面で視界の外にいる
      - 労力の大部分をユーザーストーリーの実装に集中できる
      - 顧客への提供価値を最大化できる




・モジュール化と関心事の分離
  - 管理と意思決定の分散を可能とする
  - 権限を譲渡しやすい
  - ジャストインタイムの決断を可能にする
  - 決断の複雑さも減少




・システムはドメイン特化言語を必要
  - ドメインの概念とそれを実装するコードとの「コミュニケーションギャップ」を最小化
  - コードの意図を適切な抽象レベルで見せれる
    - 












