7．エラー処理
・リターンコードより例外を使用
  - エラー処理がコードを支配する
    - エラー処理はコード全体に散在
    - エラー処理がどこにあるのかは識別困難
    - 本来のロジックを不明瞭にしがち

  - エラー時に例外を送出
    - 呼び出し側がスッキリする
    - ロジックが明瞭
    - アルゴリズムとエラー処理の関心事を分離
    - 関心事を個別に調査可能．

  - 最初にtry/catch/finallyを書く
    - 例外処理がプログラムの中にスコープを定義
    - tryブロッカがトランザクション
    - tryで何が起きても，catchで整合性をとる
    - 例外を強制的に送出するテストを書く
      - その後，テストが成功する様に処理に振る舞いを追加
      - トランザクションスコープを作成
      - トランザクションスコープの特性を維持




・非チェック例外を使用
  - pros
    - メゾッドのシグネチャに，呼び出し元に渡る例外を全て列挙

  - cons
    - 開放/閉鎖原則に反する
      - 下層の変更が，より高いレベルのシグネチャを強制する
      - 処理は変わらないのに，再ビルドと再配備が必要
      - catch間の全メゾッドのシグネチャに例外を追加
      - 
    - 変更の連鎖が上位レベルの層へと波及する
      - カプセル化が破壊される
      - 離れた場所のエラー処理を可能にする例外の目的に合わない
      - 依存性を招く




・例外で状況を伝える
  - スタックトレース
    - 失敗した処理の意図は分からん

  - エラーメッセージ
    - エラー場所
    - 失敗の種類

  - 呼び出し元が必要とする例外クラス
    - エラーの分類
      - 原因（どのコンポーネント？）
      - 失敗の種類（デバイス？  ネットワーク？  バグ？）
      - 
    - どのようにキャッチされるかが重要
    - 呼び出す例外のAPIをラップ
      - 共通の例外型を返す
      - 特定ベンダにおけるAPIの設計に依存しなくて済む
      - 自分にとって最適なAPIを別に定義




・nullを返さない
  - nullチェック
    - 1つ忘れれば，アプリケーションは制御不能になる
    - 呼び出し元に面倒を押し付ける
    - 多すぎるnullチェックが問題

  - メゾットからnullを返さない
    - nullを替えうなら例外を送出
    - スペシャルケースオブジェクトを返す
    - 空のリストなどを返す

  - third party library
    - ラップして例外を送出させる




・nullを渡さない
  - if文での制御は，exceptionの処理が必要になる
  - アサーションは，依然としてエラー
  - nullによってエラーになる問題は解決しない
  - nullを渡すことを原則禁止にするしかない




・結論
  - クリーンコードは，堅牢である必要がある
  - エラー処理によって，本流のロジックと独立する必要