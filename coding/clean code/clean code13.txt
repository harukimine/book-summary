13．同時並行性
・同時並行性の必要性
  - 分離戦略
    - 何を実行
    - いつ実行

  - 顕著な改善
    - アプリケーションの構造
      - 大きなメインループでなく，協調する小さな集まり
      - システムの理解が簡単
      - 関心事の分離
    - スループット
      - I/O待ち時間の短縮
      - 大量データの処理

  - デメリット
    - 余分．オーバーヘッド
    - 複雑
    - バグに再現性がない
    - 設計戦略の根本的な見直し
    - 同時動作
      - ジャストインタイムコンパイラのバイトコードに対する処理
      - メモリモデルが何をアトミックなものとして扱うのか




・同時並行性防御戦略
  - 単一責務の法則（SRP）
    - 分離
      - メゾット/クラス/コンポーネントは，変更の原因となるものを1つだけ持つ
      - 同時並行処理の設計は複雑なため，それ自体が1つの変更の原因
      - 同時並行性に関するコードを他のコードから分離！
    - 考慮点
      - コード自身がライフサイクル（開発，変更，チューニング）を持つ
      - 誤作動が多岐にわたるため，周りのコードに重荷

  - データのスコープを限定
    - クリティカルセッションの数を抑える
      - synchronized keyword
      - 共有オブジェクトを操作するクリティカルセッションを保護
      - 共有データが変更される場所を減らす
      - データのカプセル化

    - データのコピー
      - 読み書き出し専用
      - データの共有を避ける
      - 余分な生成とガベージコレクションのオーバーヘッドは十分に見合う

    - スレッドを独立
      - 共有されていないデータソースから読む
      - ローカル変数に格納
      - データを依存しないサブセットに分割




・実行モデルを見分ける
  - 振る舞いの分割手法
    - 束縛リソース      ：固定長リソース．終わるまで待つ．
    - 相互排他          ：同時アクセスは1スレッドまで
    - デッドロック      ：お互いのスレッドが終了を待ち合わせ
    - ライブロック      ：スレッドの足並みがそろい，互いに邪魔し合う

  - 実行モデル（大抵の同時並行処理の問題は3つのバリエーション）
      - プロヂューサー/コンシューマー
        - 間にあるキューは，束縛リソース
        - 間のシグナル通知で待ち合わせ
      - リーダー/ライター
        - ライターはリーダーを長時間ロック
        - 常駐するリーダーは，ライダーを飢餓状態
        - 正しい操作/許容範囲のスループット/飢餓状態の回避を満たし，要件の妥協点を見つける
      - 哲学者の食事
        - スレッドによるリソースの競合
        - でっとロック，ライブロック，スループット，効率低下




・同期化メゾッドの依存関係
  - システムが誤って記述
  - 共有されるオブジェクトのメゾッドを2つ以上使用しない


・同期かセクションを小さくする
  - 多いクリティカルセッションは衝突が増える
  - synchronized文は，ばら撒かない


・正確な処理コードを書くのは難しい
  - 常駐し永遠に動くシステムと，一定時間稼働するシステムは別物
  - デッドロック
  - 早い時期に終了処理について考慮し，動作する様にする


・スレッド化されたコードのテスト
  - テストで正確性は担保できない
  - リスク低減
  - 潜在的問題をあぶりだすテスト
    - 異なるプログラム構成，システム設定上で頻繁に実行
    - 失敗の原因を突き詰める


・怪しい失敗をスレッド問題野容疑者として扱う
  - スレッド化されたコードは「簡単には起きない」エラーを頻発
  - 一過性の問題だと考えない


・最初にマルチスレッド化されていないコードを完成
  - 非マルチスレッド，マルチスレッドのバグを同時に追いかけない
  - POJOを作って，自分のスレッドから呼び出す
    - マルチスレッド環境以外でも動作するようにする


・差し替え可能
  - 様々な構成で実行可能となるようにする


・チューニング可能
  - スレッドのバランスを取るには一苦労
  - スレッドの数を調整可能
  - 実行時に変更可能
  - スループット，システム，使用率をもとに自分自身をチューニング


・プロセッサの数 > スレッドの数
  - タスクスイッチを促す
  - クリティカルセッションの不備やデッドロックが見つかりやすい


・異なるプラットフォームで実行
  - OSがそれぞれ異なる実装方法
  - 早期に，頻繁に，全てのプラットフォーム上でテスト




・如何なる手で強制的にエラーを発生させる
  - 発生確率の低さから問題が隠れてしまう
  - 問題のあるセクションの経路を引けるかどうか

  - 単純なテストではダメ
    - 実行の順序を変えるメッゾドを使用
    - コードに，異なる順序，異なるタイミングで揺さぶりをかける

  - テスト
    - 実行時に，複数の校正を簡単に組み合わせれる様にする
    - システムをPOJOで構成
    - スレッドを制御するクラスとそれ以外を分離
      - コース変更を行う場所が見つけやすい

  - 自動テスト
    - アスペクト指向フレームワーク
      - 呼びたしを追加
      - ランダムにアスペクトを使用




・結論
  - マルチスレッド×共有データは，悪夢
  - 厳格なクリーンコード
  - 稀に発生するエラーに悩まされる

  - 最初に，単一責務の法則（SRP）
    - スレッドを意識するコードを小さく
    - 目的に集中できるように
    
  - 同時並行性の問題の原因となるものを理解する
  - ライブラリと基本的なアルゴリズムを理解する
  - 一過性の問題を無視しない
  - テスト容易性は，TDDの三原則を守ることで得る
  - 如何なる手で強制的にエラーを発生させる

  - コードを綺麗に保つ
    - 正しいものが出来上がる可能性は大













